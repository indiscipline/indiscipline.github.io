<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Indiscipline</title>
    <link>https://indiscipline.github.io/tags/sound/index.xml</link>
    <description>Recent content on Indiscipline</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Except where otherwise noted, content on this site is licensed under a &lt;a title=&#34;Creative Commons Attribution-NoDerivatives 4.0 International License&#34; href=&#34;http://creativecommons.org/licenses/by-nd/4.0/&#34;&gt;CC BY-ND 4.0&lt;/a&gt;.</copyright>
    <atom:link href="https://indiscipline.github.io/tags/sound/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>zrtstr - detect &amp; eliminate faux-stereo WAVs</title>
      <link>https://indiscipline.github.io/post/zrtstr-eliminate-faux-stereo/</link>
      <pubDate>Wed, 09 Nov 2016 14:27:37 +0300</pubDate>
      
      <guid>https://indiscipline.github.io/post/zrtstr-eliminate-faux-stereo/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/indiscipline/zrtstr/&#34;&gt;zrtstr&lt;/a&gt;&lt;/strong&gt; is a small command line application for detecting faux-stereo WAV-files, that is, files with two identical channels that should have been saved as mono. Such files are sometimes generated by some audio-editing software and DAWs (I&amp;rsquo;m looking at you, old Cubase 5). Gotten tired of receiving such files from clients for mixing, as they are using twice the necessary space and require twice the processing power, I decided to deal with this nuisance once and for all. zrtstr is a cross-platform application which runs very fast, thanks to being written in &lt;a href=&#34;https://rust-lang.org/&#34;&gt;Rust&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Before&amp;rdquo; and &amp;ldquo;after&amp;rdquo; waveforms:&lt;/em&gt;
&lt;img src=&#34;https://indiscipline.github.io/img/zrtstr/zrtstr-processed.png&#34; alt=&#34;zrtstr before and after&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Ideally, I wouldn&amp;rsquo;t like to see such a limited functionality in a separate application, but I found no easy and coherent way to do using usual &lt;a href=&#34;http://sox.sourceforge.net/&#34;&gt;SoX&lt;/a&gt; or ffmpeg. Which is a shame. But when life deals you such a minor problem that happens so frequently, you have nothing to do but automate the tedious actions.&lt;/p&gt;

&lt;h4 id=&#34;usage&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;zrtstr is a command-line application, but I tried to make it as easy to use as possible. To start using it, provide zrtstr with input file as an argument, or just run it from a directory full of target WAV files. The program will scan every file in its entirety and save mono-copies of detected faux-stereo files with &lt;code&gt;.MONO&lt;/code&gt; suffix. Full help available with &lt;code&gt;--help&lt;/code&gt; switch, provided by the wonderful &lt;a href=&#34;https://github.com/kbknapp/clap-rs&#34;&gt;Clap&lt;/a&gt; library.&lt;/p&gt;

&lt;h4 id=&#34;download-https-github-com-indiscipline-zrtstr-releases&#34;&gt;&lt;a href=&#34;https://github.com/indiscipline/zrtstr/releases&#34;&gt;Download&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Latest Windows &lt;strong&gt;binaries&lt;/strong&gt; are luckily provided in Github &lt;a href=&#34;https://github.com/indiscipline/zrtstr/releases&#34;&gt;releases&lt;/a&gt; page. Linux/Mac users are encouraged to build it by hand.&lt;/p&gt;

&lt;h4 id=&#34;how-does-it-work&#34;&gt;How does it work?&lt;/h4&gt;

&lt;p&gt;Zrtstr reads interleaved channel samples from a target stereo file one by one and compares left and right samples. If the difference is present (or higher than the threshold given in &lt;code&gt;--dither&lt;/code&gt; mode) than file considered true-stereo and program tries to write a mono copy.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s live output on a set of test files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ zrtstr.exe
No input file given. Processing current directory.
--- Analyzing: c:\test\32fp-faux-stereo-dithered.wav
101769 / 101769  100.00 % 17311901.54/s
Channels are identical! Faux stereo detected
  * Converting to true-mono...
  ! Writing IEEE_FLOAT files not implemented yet!
--- Analyzing: c:\test\32fp-faux-stereo.wav
101769 / 101769  100.00 % 17436110.94/s
Channels are identical! Faux stereo detected
  * Converting to true-mono...
  ! Writing IEEE_FLOAT files not implemented yet!
--- Analyzing: c:\test\dither24.MONO.wav
File is not stereo! Exiting
--- Analyzing: c:\test\dither24.wav
101769 / 101769  100.00 % 19279415.99/s
Channels are identical! Faux stereo detected
  * Converting to true-mono...
Target file already exists. Replacing...
&amp;quot;c:\test\dither24.MONO.wav&amp;quot; successfully written!
--- Analyzing: c:\test\dither32fp.wav
101769 / 101769  100.00 % 16593892.73/s
Channels are identical! Faux stereo detected
  * Converting to true-mono...
  ! Writing IEEE_FLOAT files not implemented yet!
--- Analyzing: c:\test\mono.wav
File is not stereo! Exiting
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, at the moment program doesn&amp;rsquo;t know how to write 32 bit floating-point files, as the &lt;a href=&#34;https://github.com/ruuda/hound&#34;&gt;Hound&lt;/a&gt; library doesn&amp;rsquo;t support it yet.&lt;/p&gt;

&lt;h4 id=&#34;contributing&#34;&gt;Contributing&lt;/h4&gt;

&lt;p&gt;zrtstr is a free software and distributed under GNU General Public License version 2 or later. So anyone is free to hack away and submit any reasonable patches in the repository. Feel free to file a bug report or feature request via &lt;a href=&#34;https://github.com/Indiscipline/zrtstr/issues&#34;&gt;Issues&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ReaScript: MIDI_Compress_By_Pitch</title>
      <link>https://indiscipline.github.io/post/reascript-midi-compress-by-pitch/</link>
      <pubDate>Thu, 14 Apr 2016 15:39:48 +0300</pubDate>
      
      <guid>https://indiscipline.github.io/post/reascript-midi-compress-by-pitch/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.reaper.fm/&#34;&gt;Reaper&lt;/a&gt; is a digital audio workstation that gained a lot of devoted followers since its appearance. What is special about Reaper, apart from its enormous functionality and customizability, is two things: Community and Extensibility. You can check the former on &lt;a href=&#34;https://forum.cockos.com/forumdisplay.php?f=20&#34;&gt;Reaper forums&lt;/a&gt;, which is a thriving place, but the latter is achieved via user-coded scripts and open &lt;a href=&#34;http://www.reaper.fm/sdk/reascript/reascripthelp.html&#34;&gt;API&lt;/a&gt;. Since I&amp;rsquo;ve started using Reaper as my main DAW, the temptation grew. Then finally a need for a function that wasn&amp;rsquo;t present in Reaper has arisen.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;midi-compress-by-pitch&#34;&gt;MIDI_Compress_By_Pitch&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/indiscipline/reaper_scripts/blob/master/lua/MIDI_Compress_By_Pitch.lua&#34;&gt;MIDI_Compress_By_Pitch&lt;/a&gt; is a simple &lt;a href=&#34;https://lua.org/&#34;&gt;Lua&lt;/a&gt; script for Reaper which takes selected MIDI notes and compresses/expands their velocity by a given rate, but the average velocity is computed per-pitch. The primary usage is for midi percussion or drums or any other instrument where pitches correspond to completely different sounds.&lt;/p&gt;

&lt;p&gt;Usage:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add script to Reaper

&lt;ul&gt;
&lt;li&gt;Click Menu&amp;gt;Actions&lt;/li&gt;
&lt;li&gt;Find ReaScript section, press Load&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Select your MIDI event and open MIDI editor&lt;/li&gt;
&lt;li&gt;Select the notes you want the script to work on&lt;/li&gt;
&lt;li&gt;Run the script

&lt;ul&gt;
&lt;li&gt;The processing rate is a difference of velocity for each note and the average velocity in %.&lt;/li&gt;
&lt;li&gt;First input box is per-pitch compression/expansion in %&lt;/li&gt;
&lt;li&gt;Second input is compression/expansion rate for all selected notes&lt;/li&gt;
&lt;li&gt;Use positive values for compression and negative values for expansion.&lt;/li&gt;
&lt;li&gt;Expansion value can exceed %100 (try -200 or -400)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;download-at-github-https-github-com-indiscipline-reaper-scripts-br&#34;&gt;&lt;a href=&#34;https://github.com/indiscipline/reaper_scripts/&#34;&gt;[&lt;strong&gt;Download at GitHub&lt;/strong&gt;]&lt;/a&gt;&lt;br /&gt;&lt;/h5&gt;

&lt;p&gt;Here&amp;rsquo;s the script in action:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/indiscipline/reaper_scripts/raw/master/demo/midi_compress_by_pitch.gif&#34; alt=&#34;midi_compress_by_pitch demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Using this script can help with evening the dynamics from a live-input, but it retains inter-pitch dynamic difference, so when, say, you&amp;rsquo;re playing with a MIDI-drum set your hi-hat can stay soft while your backbeat is loud as hell.&lt;/p&gt;

&lt;p&gt;Where the global expansion can help is when you need to separate the volume of different sounds which is often needed from a drum part but takes a lot of practice to achieve even playing real drums, and if you use a simple midi-controller it&amp;rsquo;s even harder.&lt;/p&gt;

&lt;p&gt;The code of the script is open under GPLv2+ license and now resides in my &lt;strong&gt;GitHub repo:&lt;/strong&gt;&lt;br /&gt; &lt;a href=&#34;https://github.com/indiscipline/reaper_scripts/&#34;&gt;https://github.com/indiscipline/reaper_scripts/&lt;/a&gt;
This is my first working script in Lua, so any corrections and suggestions are welcome. Reaper allows using a whole lot of three languages for writing scripts, the other two being Python, which is not bundled with Reaper (but very likely sits on your machine already) and homebrewed EEL which is clearly C-inspired. What drew me to Lua in this case is that Reaper doesn&amp;rsquo;t need a separate interpreter for it and it&amp;rsquo;s a widely used script language with easy to find documentation, help and existing code snippets.&lt;/p&gt;

&lt;p&gt;At this point my impressions of Lua are mixed, but this is probably due to my previous almost exclusive usage of compiled, strongly typed languages like my favourite &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt;. Lua is very simple so at many places I kept thinking: How is my variable passed? What about coercion? Where&amp;rsquo;s Pattern-matching and Map and function return type? This probably should be evident from the code. Oh, and I&amp;rsquo;m completely spoiled by extensive compiler feedback and corrections!&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>